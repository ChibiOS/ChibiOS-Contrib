/*
    ChibiOS - Copyright (C) 2024 Xael South

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#include <string.h>
#include "cmsis_os.h"
#include "hal.h"

#include "em_device.h"
#include "sl_rail_util_init.h"
#include "rail_types.h"
#include "rail.h"

#if 0
static uint8_t payload_C_MODE_FRAME_B[] ={   0x54, 0x3D, 0x54, 0x3D, // Sync Byte_1 to Sync Byte_4  for C-Mode, Frame-B
  0x2F, 0x44, 0xC5, 0x14, 0x89, 0x42, 0x61, 0x20, 0x31, 0x08, 0x7A, 0x53, 0x0B, 0x00, 0x20, 0x2F,
  0x2F, 0x04, 0x6D, 0x34, 0x2C, 0xD3, 0x2A, 0x03, 0x6E, 0x00, 0x00, 0x00, 0x42, 0x6C, 0x00, 0x00,
  0x43, 0x6E, 0x00, 0x00, 0x00, 0x31, 0x7F, 0x08, 0x34, 0x6D, 0x19, 0x31, 0xDE, 0x29, 0xF0, 0x50
};

static uint8_t payload_C_MODE_FRAME_A[] ={   0x54, 0x3D, 0x54, 0xCD, // Sync Byte_1 to Sync Byte_4 for C Mode, Frame A
  0x31, 0x44, 0x93, 0x44, 0x48, 0x32, 0x75, 0x26, 0x35, 0x08, 0x6D, 0x95, 0x7A, 0xA3, 0x00, 0x00,
  0x20, 0x0B, 0x6E, 0x16, 0x00, 0x00, 0x4B, 0x6E, 0x21, 0x02, 0x00, 0x42, 0x91, 0xDD, 0x6C, 0xBF,
  0x2A, 0xCB, 0x08, 0x6E, 0x16, 0x00, 0x00, 0xC2, 0x08, 0x6C, 0xDE, 0x29, 0x32, 0x6C, 0x8C, 0xC4,
  0xFF, 0xFF, 0x04, 0x6D, 0x27, 0x0E, 0xD2, 0x2A, 0x3D, 0x89
};
#endif

static uint8_t payload_C_MODE_FRAME[] =
{ 0x31, 0x44, 0x93, 0x44, 0x48, 0x32, 0x75, 0x26, 0x35, 0x08, // 0x6D, 0x95,
  0x7A, 0xA3, 0x00, 0x00, 0x20, 0x0B, 0x6E, 0x16, 0x00, 0x00, 0x4B, 0x6E, 0x21, 0x02, 0x00, 0x42, // 0x91, 0xDD,
  0x6C, 0xBF, 0x2A, 0xCB, 0x08, 0x6E, 0x16, 0x00, 0x00, 0xC2, 0x08, 0x6C, 0xDE, 0x29, 0x32, 0x6C, // 0x8C, 0xC4,
  0xFF, 0xFF, 0x04, 0x6D, 0x27, 0x0E, 0xD2, 0x2A, // 0x3D, 0x89
};

CC_ALIGN_DATA(16)static uint8_t railFifo[1024];

static void led_on(void) {

  /* PB2 = LED */
  palSetPadMode(GPIOB, 2, PAL_MODE_OUTPUT_PUSHPULL);
  palSetPad(GPIOB, 2);
}

static void led_off(void) {

  /* PB2 = LED */
  palSetPadMode(GPIOB, 2, PAL_MODE_OUTPUT_PUSHPULL);
  palClearPad(GPIOB, 2);
}

void st_callback(unsigned alarm) {

  stStopAlarmN(alarm);
  stStartAlarmN(alarm, stGetCounter() + chTimeMS2I(3000));
}

void RAIL_eventsCallback(RAIL_Handle_t railHandle, RAIL_Events_t events) {

  (void)railHandle;
  (void)events;

  return;
}

void RAIL_InitCompleteCallback(RAIL_Handle_t railHandle) {

  (void)railHandle;

  return;
}

#if 0
#define SL_RAIL_UTIL_INIT_INST0_ENABLE 1

// <h> Project Configuration
// <q SL_RAIL_UTIL_INIT_RADIO_CONFIG_SUPPORT_INST0_ENABLE> Enable Radio Configurator Support (include rail_config.c/h generated by Radio Config)
// <i> Default: 0
#define SL_RAIL_UTIL_INIT_RADIO_CONFIG_SUPPORT_INST0_ENABLE 1
// <q SL_RAIL_UTIL_INIT_INIT_COMPLETE_CALLBACK_INST0_ENABLE> Enable RAIL Init Complete Callback
// <i> Default: 0
#define SL_RAIL_UTIL_INIT_INIT_COMPLETE_CALLBACK_INST0_ENABLE 1
// </h>

// <e SL_RAIL_UTIL_INIT_DATA_FORMATS_INST0_ENABLE> Data Format Configuration
// <i> Default: 0
#define SL_RAIL_UTIL_INIT_DATA_FORMATS_INST0_ENABLE 1
// <h> TX Data
// <o SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_SOURCE> Source of TX Data
// <TX_PACKET_DATA=> Use frame hardware to packetize data
// <i> Default: TX_PACKET_DATA
#define SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_SOURCE  TX_PACKET_DATA
// <o SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_MODE> Method of Providing TX Data
// <PACKET_MODE=> Packet Mode
// <FIFO_MODE=> FIFO Mode
// <i> Default: PACKET_MODE
#define SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_MODE  PACKET_MODE
// </h>
// <h> RX Data
// <o SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_SOURCE> Source of RX Data
// <RX_PACKET_DATA=> Use frame hardware to packetize data
// <RX_DEMOD_DATA=> Get 8-bit output from demodulator
// <RX_IQDATA_FILTLSB=> Get lowest 16 bits of I/Q data provided to demodulator
// <RX_IQDATA_FILTMSB=> Get highest 16 bits of I/Q data provided to demodulator
// <i> Default: RX_PACKET_DATA
#define SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_SOURCE  RX_PACKET_DATA
// <o SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_MODE> Method of Retrieving RX Data
// <PACKET_MODE=> Packet Mode
// <FIFO_MODE=> FIFO Mode
// <i> Default: PACKET_MODE
#define SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_MODE  PACKET_MODE


void my_RAIL_Init(void) {

  RAIL_Status_t status;
  RAIL_Config_t sl_rail_config = {
    .eventsCallback = &RAIL_eventsCallback,
    // Other fields are ignored nowadays
  };
  (void) status; // Suppress compiler warning if status ends up unused

  RAIL_Handle_t sl_rail_handle_inst0 = RAIL_Init(&sl_rail_config,
                             &RAIL_InitCompleteCallback
                             );

  RAIL_DataConfig_t data_config = {
    .txSource = SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_SOURCE,
    .rxSource = SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_SOURCE,
    .txMethod = SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_TX_MODE,
    .rxMethod = SL_RAIL_UTIL_INIT_DATA_FORMAT_INST0_RX_MODE,
  };
  status = RAIL_ConfigData(sl_rail_handle_inst0, &data_config);

  const RAIL_ChannelConfig_t *channel_config = NULL;

  //channel_config = channelConfigs;

  (void) RAIL_ConfigChannels(sl_rail_handle_inst0,
                             channel_config,
                             NULL);

  status = RAIL_ConfigEvents(sl_rail_handle_inst0,
                             RAIL_EVENTS_ALL,
                             RAIL_EVENTS_NONE);
}
#endif

/*
 * Application entry point.
 */
int main(void) {

  int unused = 0;
  (void)unused;

  /* HAL initialization, this also initializes the configured device drivers
     and performs the board-specific initializations.*/
  halInit();

  /* The kernel is initialized but not started yet, this means that
     main() is executing with absolute priority but interrupts are
     already enabled.*/
  osKernelInitialize();

  /* Kernel started, the main() thread has priority osPriorityNormal
     by default.*/
  osKernelStart();

  led_off();
  led_on();

  stSetCallback(1, st_callback);
  //stStartAlarmN(1, stGetCounter() + chTimeMS2I(3000));

  //RAIL_Config_t railCfg = { .eventsCallback = RAIL_eventsCallback };
  //RAIL_Handle_t railHandle = RAIL_Init(&railCfg, RAIL_InitCompleteCallback);
  //sl_rail_util_init();

  sl_rail_util_init();

  RAIL_Handle_t railHandle = sl_rail_util_get_handle(SL_RAIL_UTIL_HANDLE_INST0);


  //RAIL_SetFixedLength(railHandle, RAIL_SETFIXEDLENGTH_INVALID);
  //RAIL_WriteTxFifo(railHandle, payload_C_MODE_FRAME, sizeof(payload_C_MODE_FRAME), true);

  /*
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state.
   */
  while (true) {
    osDelay(2000);

    #define RAIL_CHANNEL_0  0
    memcpy(railFifo, payload_C_MODE_FRAME, sizeof(payload_C_MODE_FRAME));
    RAIL_SetTxFifo(railHandle, railFifo, sizeof(payload_C_MODE_FRAME), sizeof(railFifo));
    RAIL_StartTx(railHandle, RAIL_CHANNEL_0, RAIL_TX_OPTIONS_DEFAULT, NULL);
  }
}

